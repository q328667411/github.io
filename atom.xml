<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱喝奶昔吗°</title>
  
  <subtitle>Rain</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiang.bio/"/>
  <updated>2020-10-16T01:31:43.806Z</updated>
  <id>https://xiang.bio/</id>
  
  <author>
    <name>温暖如湘</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jenkins+git+maven集成部署</title>
    <link href="https://xiang.bio/posts/e49f0579.html"/>
    <id>https://xiang.bio/posts/e49f0579.html</id>
    <published>2020-10-16T01:04:43.000Z</published>
    <updated>2020-10-16T01:31:43.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>jenkins+git+maven集成部署</h1><h2 id="什么是jenkins">什么是jenkins?</h2><blockquote><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p></blockquote><h2 id="使用jenkins的好处">使用jenkins的好处</h2><ol><li>解放了重复性劳动<br>自动化部署工作可以解放了集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工的高很多。</li><li>更快地修复问题<br>由于持续集成更早的获取变更，更早的进入测试，也就能更早的发现问题，解决问题的成本显著下降。</li><li>更快地交付成果<br>及早集成、及早测试减少了缺陷遗留到部署环节的机会。在某些情况下，更早地查找错误还会减少解决错误所需的工作量。<br>如果集成服务器对代码进行构建过程中发现错误，可以及时发送邮件或者短信提供给开发人员进行修复。<br>如果集成服务器在部署环节发现当前版本有问题不可用，集成服务器会将部署回退到上一个版本。这样服务器上始终都会有一个可用的版本。</li><li>减少手工的错误<br>人与机器的一个最大的区别是，在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。所以，当我们搭建完成集成服务器后，以后的事就交给集成服务器、来打理吧。</li><li>减少了等待时间<br>持续集成缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时间。持续集成，意味着开发、集成、测试、部署也得以持续。</li><li>更高的产品质量<br>集成服务器往往提供 Code review、代码质量检测等功能。对代码不规范或者有错误的地方会进行标识，也可以设置邮件、短信等进行告警。而开发人员通过 Code review 也可以持续提高编程的能力。</li></ol><h2 id="jenkins的执行过程">jenkins的执行过程</h2><p><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/jj.png" alt="*"><br>分别用了3台服务器来进行演示jenkins是如何进行集成部署的<br><em>当开发人员提交代码到git或者svn仓库中时，jenkins就会去仓库中拉取最新的代码，进行编译、测试、打包、部署，最终打包在tomcat服务器中</em></p><h2 id="jenkins安装">jenkins安装</h2><p>先去官网下好jenkins的war包，该war包在linux和windows是通用的  <a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a><br>下好之后把jenkins.war包放在tomcat中的wabaps中然后启动tomcat就行了，<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/1.png" alt="*"><br>启动之后，需要先去提示找到密码进行登录，登录之后选择“安装推荐插件”，安装完之后就出现如下，<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/3.png" alt="*"><br>现在我们需要先去安装jenkins的插件来执行自动集成的操作，<br>选择左侧的Manage Jenkins →Manage Plugins→安装Deploy to container Plugin插件<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/4.png" alt="*"><br>然后在去全局工具配置中配置git、maven、jdk,并设置maven的settings.xml的位置，该配置用于jenkins用于打包pom文件中jar包<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/5.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/6.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/7.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/8.png" alt="*"><br>接下来配置完后就可以创建一个项目了<br>去首页新建item选择第一个选项 “自由的项目”<br>配置git的项目地址 Repository URL 输入 你要拉取项目的地址并在Credentials中设置git账号和密码<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/9.png" alt="*"><br>构建触发器，这个就是用来去git/svn仓库去拉取代码，我选择了第一个，用钩子程序来通知jenkins来工作，身份验证令牌的格式：<a href="http://xn--ip-im8ckc">http://ip地址</a>:端口号/jenkins/job/apple/build?token=ATGUIGU_TOKEN<br>ATGUIGU_TOKEN代表身份验证令牌的名称，定义之后可以在浏览器中输入  来执行jenkins<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/10.png" alt="*"><br>告诉maven以什么样的方式进行构建，每次执行都会执行clean package操作<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/11.png" alt="*"><br>到这一步就是jenkins已经打包好了，准备部署到tomcat服务器上，WAR/EAR files设置war包的位置，Context path设置启动tomcat以什么样的方式访问  我这配置的访问路径  <a href="http://192.168.253.8:8080/apple">http://192.168.253.8:8080/apple</a><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/12.png" alt="*"><br>到这就配置完了，就可以开始执行jenkins了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python爬虫总结</title>
    <link href="https://xiang.bio/posts/915f1f31.html"/>
    <id>https://xiang.bio/posts/915f1f31.html</id>
    <published>2020-09-28T01:08:38.000Z</published>
    <updated>2020-09-28T03:02:48.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>爬虫是什么?</h1><blockquote><p>网络爬虫，又被称为网页蜘蛛，网络机器人，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本<br>大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。<br>简单来讲，爬虫就是一个探测机器，它的基本操作就是模拟人的行为去各个网站溜达，点点按钮，查查数据，或者把看到的信息背回来。就像一只虫子在一幢楼里不知疲倦地爬来爬去。<br>可以简单地想象：每个爬虫都是你的“分身”。就像孙悟空拔了一撮汗毛，吹出一堆猴子一样。<br>我们每天使用的百度，其实就是利用了这种爬虫技术：每天放出无数爬虫到各个网站，把他们的信息抓回来，然后化好淡妆排着小队等你来检索。</p></blockquote><h1>爬虫的BeautifulSoup库详解</h1><p>BeautifulSoup灵活又方便的网页解析库，处理高效，支持多种解析器。<br>利用它不用编写正则表达式即可方便地实现网页信息的提取。</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><h2 id="基本使用">基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="hljs-string">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.prettify())      <span class="hljs-comment"># 输出文档中所有内容</span><br>print(soup.title.string)    <span class="hljs-comment"># 输出&lt;title&gt;标签内容</span><br></code></pre></td></tr></table></figure><h2 id="标签选择器">标签选择器</h2><h3 id="选择元素">选择元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.title)<span class="hljs-comment"># 输出title标签</span><br>print(type(soup.title))<span class="hljs-comment"># 输出标签类型</span><br>print(soup.head) <span class="hljs-comment"># 输出hean标签</span><br>print(soup.p)<span class="hljs-comment"># 输出第一个p标签</span><br></code></pre></td></tr></table></figure><h3 id="获取名称">获取名称</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.title.name)<span class="hljs-comment"># 输出标签名</span><br></code></pre></td></tr></table></figure><h3 id="获取属性">获取属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.p.attrs[<span class="hljs-string">&#x27;name&#x27;</span>])<span class="hljs-comment"># 输出p标签中name属性值</span><br>print(soup.p[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-comment"># 输出p标签中name属性值</span><br></code></pre></td></tr></table></figure><h3 id="获取内容">获取内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.p.string) <span class="hljs-comment"># 输出p标签中的内容</span><br></code></pre></td></tr></table></figure><h3 id="嵌套选择">嵌套选择</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.head.title.string) <span class="hljs-comment"># 输出title中的内容</span><br></code></pre></td></tr></table></figure><h2 id="标准选择器">标准选择器</h2><h3 id="find-all-name-attrs-recursive-text-kwargs">find_all( name , attrs , recursive , text , **kwargs )</h3><p>可根据标签名、属性、内容查找文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">html=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="hljs-string">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.find_all(<span class="hljs-string">&#x27;ul&#x27;</span>))<span class="hljs-comment"># find_all是一个list,输出全部&lt;ul&gt;</span><br>print(type(soup.find_all(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># 获得第一个ul的类型</span><br></code></pre></td></tr></table></figure><h3 id="find-name-attrs-recursive-text-kwargs">find( name , attrs , recursive , text , **kwargs )</h3><p>find返回单个元素，find_all返回所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>))<span class="hljs-comment"># 找到第一个ul</span><br>print(type(soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>))) <span class="hljs-comment">#找到第一个ul类型</span><br>print(soup.find(<span class="hljs-string">&#x27;page&#x27;</span>))<span class="hljs-comment">#查找page</span><br></code></pre></td></tr></table></figure><p><strong>find_parents() find_parent()</strong><br>find_parents()返回所有祖先节点，find_parent()返回直接父节点。</p><p><strong>find_next_siblings() find_next_sibling()</strong><br>find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。</p><p><strong>find_previous_siblings() find_previous_sibling()</strong><br>find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。</p><p><strong>find_all_next() find_next()</strong><br>find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点</p><p><strong>find_all_previous() 和 find_previous()</strong><br>find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点</p><h2 id="CSS选择器">CSS选择器</h2><p>通过select()直接传入CSS选择器即可完成选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">html=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="hljs-string">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.select(<span class="hljs-string">&#x27;.panel .panel-heading&#x27;</span>))<br>print(soup.select(<span class="hljs-string">&#x27;ul li&#x27;</span>))<br>print(soup.select(<span class="hljs-string">&#x27;#list-2 .element&#x27;</span>))<br>print(type(soup.select(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li>推荐使用lxml解析库，必要时使用html.parser</li><li>标签选择筛选功能弱但是速度快</li><li>建议使用find()、find_all() 查询匹配单个结果或者多个结果</li><li>如果对CSS选择器熟悉建议使用select()</li><li>记住常用的获取属性和文本值的方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis实现主从复制</title>
    <link href="https://xiang.bio/posts/39474014.html"/>
    <id>https://xiang.bio/posts/39474014.html</id>
    <published>2020-08-21T02:35:07.000Z</published>
    <updated>2020-08-21T03:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Redis主从复制？">什么是Redis主从复制？</h2><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，<br>但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/1.png" alt="*"><br>说明:</p><ul><li>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</li><li>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。只有一个主redis，可以有多个从redis。</li><li>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</li><li>一个redis可以即是主又是从</li></ul><h2 id="主从配置">主从配置</h2><p>现在我们需要修改redis中的redis.conf中的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">将daemonze由no改为yes(Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程)<br>#bind 127.0.0.1 取消绑定本机IP  任意主机都能连上<br>daemonize yes 守护进程修改yes<br>protected-mode no保护模式，修改成NO<br>replicaof 主redis IP地址 端口号修改主从同步配置(只需要改从服务器)<br></code></pre></td></tr></table></figure><p>现在就要 开始启动redis看看效果，redis启动主要分为<strong>前端启动</strong>和<strong>后端启动</strong></p><h3 id="前端启动-font-color-red-不推荐-font">前端启动(<font color="red">不推荐</font>)</h3><ul><li>启动命令：redis-server，直接运行bin/redis-server将以前端模式启动。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-server<br></code></pre></td></tr></table></figure></li><li>关闭命令：ctrl+c</li></ul><p>启动缺点：客户端窗口关闭则redis-server程序结束，不推荐使用此方法<br>启动图例<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/2.png" alt="*"></p><h3 id="后端启动-守护线程启动">后端启动(守护线程启动)</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">redis-server redis.conf<br></code></pre></td></tr></table></figure><h3 id="后端启动的关闭方式">后端启动的关闭方式</h3><ul><li>非正常关闭（不推荐使用）：</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">kill -9  pid <br></code></pre></td></tr></table></figure><ul><li>正常关闭</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-cli shutdown<br></code></pre></td></tr></table></figure><h3 id="其他命令说明">其他命令说明</h3><ul><li>redis-server ：启动redis服务</li><li>redis-cli ：进入redis命令客户端</li><li>redis-benchmark： 性能测试的工具</li><li>redis-check-aof ： aof文件进行检查的工具</li><li>redis-check-dump ：  rdb文件进行检查的工具</li><li>redis-sentinel ：  启动哨兵监控服务</li></ul><p>启动redis图解<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/3.png" alt="*"></p><p>分别启动主redis和从redis服务，会发现从redis只有读的权限没有写的权限，并且主redis插入数据时从redis会同步更新(会有1秒左右的延迟)，下图就实现了reids的主从复制<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/4.png" alt="*"></p><h3 id="实现原理">实现原理</h3><ul><li>Redis的主从同步，分为全量同步和增量同步。</li><li>只有从机第一次连接上主机是全量同步</li><li>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</li><li>除此之外的情况都是增量同步<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/5.png" alt="*"></li></ul><h2 id="Redis-Sentinel哨兵机制">Redis Sentinel哨兵机制</h2><p>*** Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举 ***</p><h3 id="什么是哨兵机制？">什么是哨兵机制？</h3><ul><li>Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态</li><li>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</li><li>通俗的话来说就是一个保安负责小区的安全，每天监控着小区，redis中的哨兵机制亦是如此，监控着主从redis中当我们的主redis挂掉以后，可以让从redis顶上主redis的位置，实现高可用</li></ul><h3 id="哨兵进程的作用">哨兵进程的作用</h3><ol><li>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</li><li>提醒(Notification)： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作。</li></ol><ul><li>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</li><li>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</li><li>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</li></ul><h3 id="哨兵进程的工作方式">哨兵进程的工作方式</h3><ol><li>每个Sentinel（哨兵）进程以<font color="red">每秒钟一次</font>的频率向整个集群中的<font color="red">Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程</font>发送一个<font color="red">PING</font>  命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为<font color="red">主观下线（SDOWN）</font>。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<font color="red">所有 Sentinel（哨兵）</font>进程要以每秒一次的频率<font color="red">确认Master主服务器</font>的确<font color="red">进入了主观下线状态</font>。</li><li><font color="red">当有足够数量的Sentinel（哨兵）</font>进程（大于等于配置文件指定的值）在指定的时间范围内<font color="red">确认Master主服务器进入了主观下线状态（SDOWN）</font>， 则Master主服务器会被标记为<font color="red">客观下线（ODOWN）</font>。</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为<font color="red">客观下线（ODOWN）</font>时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/6.png" alt="*"></li></ol><p>只需要修改从redis中sentinel.conf</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-cli shutdown<br></code></pre></td></tr></table></figure><ul><li>启动主redis和从redis后，通过redis-sentinel启动哨兵服务</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-sentinel sentinel.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
