<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱喝奶昔吗°</title>
  
  <subtitle>Rain</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiang.bio/"/>
  <updated>2020-10-26T06:53:05.434Z</updated>
  <id>https://xiang.bio/</id>
  
  <author>
    <name>温暖如湘</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ安装以及原理</title>
    <link href="https://xiang.bio/posts/22aaf7c4.html"/>
    <id>https://xiang.bio/posts/22aaf7c4.html</id>
    <published>2020-10-26T06:10:10.000Z</published>
    <updated>2020-10-26T06:53:05.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>什么是消息队列？</h1><p>消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，爷可以更复杂，可以包含嵌入对象。<br>消息队列(Message Queue)是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保信息的可靠传递。消息发布者只管把消息发布到MQ中而不用管谁来取，消息使用者只管从MQ中取消息而不管是谁发布的，这样发布者和使用者都不用知道对方的存在</p><h1>为什么要使用消息队列</h1><p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用MQ呢？<br>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括:扣减库存、生成响应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下用MQ，在下单的主流程(比如扣减库存、生成相应单据)完成之后发送一条消息到MQ让主流程快速完结，而由另外的单独线程拉取MQ的消息(或者由MQ推送消息)，当发现MQ种有红包或发短信之类的消息时，执行相应的业务逻辑。<br>以上时用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。<br><img src= "/img/loading.gif" data-lazy-src="/posts/22aaf7c4/rabbitmq%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="*"></p><h1>RabbitMQ特点</h1><p>RabbitMQ是一个由Erlang语言开发的AMQP的开源实现。<br>AMQP:Advanced Message Queue,高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br>Rabbitmq最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性<br>RabbitMQ使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由<br>在消息进入队列之前，通过Exchange来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。</li><li>消息集群<br>多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>高可用<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用</li></ol><p>#安装RabbitMQ</p><ol><li><p>安装erlang<br>下载: wget <a href="http://www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm">http://www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</a><br>安装: rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</p></li><li><p>安装socat<br>下载: wget <a href="http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm">http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</a><br>安装: rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</p></li><li><p>安装rabbitmq<br>下载: wget <a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</a><br>安装: rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</p></li></ol><h2 id="启动rabbitmq服务">启动rabbitmq服务</h2><p>安装完成后, 还没启动服务, 先查看rabbitmq服务状态, 命令: service rabbitmq-server status<br>OK, 启动rabbitmq服务, 命令: service rabbitmq-server start, 检查是否启动成功: ps -ef | grep rabbitmq</p><h2 id="启用后台管理插件">启用后台管理插件</h2><p>此时, 服务已经启动, 但通过浏览器访问http://localhost:15672或ip:15672还是不能访问管理界面, 因为还没启用插件, 启用命令: rabbitmq-plugins enable rabbitmq_management, 提示Applying plugin configuration to rabbit@wangzaiplus… started 6 plugins.即表示启用成功</p><h2 id="RabbitMQ安装成功后使用默认用户名guest登录">RabbitMQ安装成功后使用默认用户名guest登录</h2><p>账号: guest<br>密码: guest<br>注意:这里guest只允许本机登录访问需要创建用户并授权远程访问命令如下</p><ol><li>添加用户: rabbitmqctl add user {username} {password}</li></ol><blockquote><p>rabbitmqctl add user root root</p></blockquote><ol start="2"><li><p>删除用户: rabbitmqctl delete user {username}</p></li><li><p>修改密码: rabbitmqctl change password {username} {newpassword}</p></li></ol><blockquote><p>rabbitmqctl user root adminstrator</p></blockquote><ol start="4"><li>设置用户角色: rabbitmqctl set user tags {username} {tag}<br>tag参数表示用户角色取值为:management,monitoring,policymaker,administrator<br>各角色详解:</li></ol><ul><li>management:用户可以通过AMQP做任何事外加:列出自己可以通过AMQP做的任何事外</li></ul><h2 id="启动和关闭">启动和关闭</h2><ol><li>启动RabbitMQ<br>rabbitmq-server start<br>注意:这里可能会出现错误，错误原因是/var/lib/rabbitmq/.erlag.cookie文件权限不够。<br>解决方案对这个文件授权</li></ol><blockquote><p>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie<br>chmod 400 /var/lib/rabbitmq/.erlang.cookie</p></blockquote><ol start="2"><li>停止服务<br>rebbitmqctl stop</li></ol><h1>vhost管理</h1><p>vhost是RabbitMQ中的一个命名空间，可以限制消息的存放位置利用这个命名空间可以进行权限管理的控制有点类似Windows中的文件夹一样，在不同的文件夹中存放不同的文件<br>添加： vhost:rabbitmqctl add vhost {name}<br>例如: rabbitmqctl add vhost bjpowernode<br>删除 vhost: rannitmqctl delete vjost {name}<br>例如: rabbitmqctl delete vhost bjpowernode</p><h1>RabbitMQ的消息发送和接收机制</h1><p>所有MQ产品从模型抽象上来说都是一样的过程:<br>消费者(consumer)订阅某个队列。生产者(producer)创建消息,然后发布到队列(queue)中，最后将消息发送到监听的消费者。<br><img src= "/img/loading.gif" data-lazy-src="/posts/22aaf7c4/%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6.png" alt="*"><br>上面是MQ的基本抽象模型，但是不同的MQ产品有着不同的机制，RabbitMQ实际基于AMQP协议的一个开源实现，因此RabbitMQ内部也是AMQP的基本概念</p><h1>交换机类型</h1><h2 id="direct-单播模式">direct (单播模式)</h2><p>消息中的路由键(routing key)如果和Binding中的binding key一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发routing key 标记为“dog”的消息，不会转发“dog.puppey”,也不会转发“dog.guard”等等，它是完全匹配、单播的模式。<br><img src= "/img/loading.gif" data-lazy-src="/posts/22aaf7c4/direct.png" alt="*"><br>fanout(广播模式)<br>每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的讲队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上，很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的<br><img src= "/img/loading.gif" data-lazy-src="/posts/22aaf7c4/fanout.png" alt="*"><br>topic(匹配模式)<br>topic交换器通过模式分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，“</em>”匹配不多不少一个单词<br><img src= "/img/loading.gif" data-lazy-src="/posts/22aaf7c4/topic.png" alt="*"></p><h1>事务消息</h1><p>事务消息于数据库的事务类似，只是MQ中的消息是要保证消息是否会全部发送成功，防止丢失消息的一种策略。<br>RabbitMQ有两种方式来解决这个问题</p><ol><li>通过AMQP提供的事务</li><li>使用发送者确认模式<br>channel.waitForConfirms()普通发送方确认模式<br>channel.waitForConfirmsOrDie()批量确认模式<br>channel.addConfirmListener()异步监听发送方确认模式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker总结</title>
    <link href="https://xiang.bio/posts/f59415f7.html"/>
    <id>https://xiang.bio/posts/f59415f7.html</id>
    <published>2020-10-21T06:48:23.000Z</published>
    <updated>2020-10-26T06:47:24.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Docker是什么？</h1><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。<br>Docker之所以发展迅速，也是因为它对此给出了一个标准化的解决方案。<br>环境配 置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<font color="FF0000"> 软件可以带环境安装？ </font>也就是说，<font color="FF0000"> 安装的时候，把原始环境一模一样的复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可正常工作”的问题</font></p><h1>Docker的基本组成</h1><h2 id="镜像">镜像</h2><p>Docker镜像(Image)就是一个<font color="FF0000">只读</font>模板。镜像可以用来创建Docker容器，<br>容器与镜像的关系类似于面向对象中对象与类。</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><h2 id="容器">容器</h2><p>Docker利用容器(Container)独立运行的一个或一组应用。<font color="FF0000">容器是用镜像创建的运行实例</font>。<br>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br><font color="FF0000">可以把容器看做是一个简易版的Linux环境</font>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。<br>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h2 id="仓库">仓库</h2><p>仓库(Repository)是<font color="FF0000">集中存放镜像</font>文件的场所<br>仓库(Repository)和仓库注册服务器(Registry)是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含多个镜像，每个镜像又不同的标签(tag)。<br>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。<br><font color="FF0000">最大的公开仓库是Docer Hub(<a href="Https://hub.docer.com/">Https://hub.docer.com/</a>)</font>,<br>存放了数量庞大的镜像供用户下载，国内的公开仓库包括阿里云、网易云等。</p><h2 id="小总结">小总结</h2><p>需要正确的理解仓储/镜像/容器几个概念:<br>Docer本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎image镜像文件。只有通过这个镜像文件才能生成Docker容器。imag文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p><ul><li>image文件生成的容器实例，本身也是一个文件，成为镜像文件</li><li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li><li>至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了</li></ul><h1>Docker安装</h1><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><blockquote><p>yum install -y yum-utils device-mapper-persistent-data lvm2<br>设置yum源(阿里仓库)<br>yum-config-manager --add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br>安装docker(如果想指定模板只需要在ce后面加上版本号  例如:docker-ce-18.03.1.ce，默认安装最新的)<br>yum install docker-ce<br>启动Docker(重启Docker：service docker restart)<br>systemctl start docker<br>配置Docker加速器<br>vi /etc/docker/daemon.json</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://azuumh1g.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h1>Docker是怎么工作的？</h1><p>Docker是一个Client-Server结构的系统，Docker守护线程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器，<font color="FF0000">容器是一个运行时环境</font><br><img src= "/img/loading.gif" data-lazy-src="/posts/f59415f7/2.png" alt="*"></p><h1>为什么Docker比VM(虚拟机)快？</h1><ol><li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</li><li>docker利用的是宿主机的内涵，而不需要Guest os。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，加载操作系统内核返个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件序员加载Guest OS,返个新建过程时分钟级别的。而docker由于直接利用宿主机的操作系统，则省略返个过程，因此新建一个docker容器只需要几秒钟<br>| | Docker容器     | 虚拟机(VM)|<br>|-------- | ----- | -----|<br>|操作系统  | 与宿主机共享OS | 宿主机OS上运行虚拟机OS |<br>|存储大小  | 镜像小、便于存储与传输 | 镜像庞大(vmdk、vdi等) |<br>|运行性能  | 几乎无额外性能损耗   | 操作系统额外的CPU、内存消耗|<br>|移植性 |   轻便、灵活、适应于Linux  |   笨重，与虚拟化技术耦合度高|<br>|硬件亲和性   |   面向软件开发者 | 面向硬件开发者 |<br>|部署速度    |   快速、秒级   |   较慢、10s以上 |</li></ol><h1>运行第一个docker程序</h1><p><img src= "/img/loading.gif" data-lazy-src="/posts/f59415f7/1.png" alt="*"><br>在上图中我运行了docker run hello-world,我解释下序号中代表什么意思</p><ol><li>代表docker在本地中并没有找到 “hello-world”这个镜像</li><li>去之前配置的那个镜像地址中也就是阿里云仓库去查有没有hello-world这个镜像，发现有  可以看到sha256后面的一串字符串</li><li>代表成功运行了&quot;hello-world&quot;并输出</li></ol><h2 id="docker-run执行了什么？">docker run执行了什么？</h2><p><img src= "/img/loading.gif" data-lazy-src="/posts/f59415f7/run.png" alt="*"></p><h1>Docker常用命令</h1><ul><li>docker images<br><img src= "/img/loading.gif" data-lazy-src="/posts/f59415f7/3.png" alt="*"></li></ul><blockquote><p>REPOSITORY: 表示镜像的仓库源<br>TAG: 镜像的标签<br>IMAGE ID:镜像ID<br>CREATED: 镜像创建时间<br>SIZE：镜像大小<br>同一个仓库可以有多个TAG,代表这个仓库源的不同版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果不指定一个镜像的版本标签，例如你只使用ubutu,docker讲默认使用肻：latest镜像</p></blockquote><h1>镜像是什么</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><h1>使用镜像centos:latest以后台模式启动一个容器</h1><p>docker run -d centos</p><h1>docker 镜像</h1><p>UnionFS(联合文件系统): Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。<br>特性：一次同时加载多个文件系统，单从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h2 id="Docker镜像加载原理">Docker镜像加载原理:</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bbotfs(boot file system)主要包含bootloader和kermel,bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层时是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs(root file system),在bootfs之上，包含的就是典型Linux系统中的/dev,/proc,/bin,/etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu,Centos等等。<br>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？<br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了，由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p><h2 id="分层的镜像">分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。</p><h3 id="为什么Docker镜像要采用这种分层结构呢？">为什么Docker镜像要采用这种分层结构呢？</h3><p>最大的一个好处就是-共享资源<br>比如:有多个镜像从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需要一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。</p><h2 id="特点">特点</h2><p>Docker镜像都是只读的<br>当容器启动时，一个行的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><h1>Docker容器数据卷</h1><h2 id="数据卷是什么？">数据卷是什么？</h2><p>先来看看Docker的理念:</p><ul><li>将运行与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li><li>容器之间希望有可能共享数据</li></ul><h2 id="数据卷能干什么？">数据卷能干什么？</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能绕过Union File System提供一些用于持续存储或共享数据的特性：<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载懂数据卷<br>特点:</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p>Dokcer容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然就没有了。<br>为了能保存数据在docker中我们使用卷。</p><h2 id="添加数据卷的两种方式">添加数据卷的两种方式</h2><h3 id="直接命令添加">直接命令添加</h3><p>docker run -it -v /宿主机绝对路径目录:/容器内目录     镜像名<br>docker run -it -v /mydataVolume:/dataVolumecontainer     镜像名<br>docker run -it -v /mydataVolume:/dataVolumecontainer:ro     镜像名   (ro)代表只读</p><h3 id="DockerFile添加">DockerFile添加</h3><p>FROM centos<br>VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]<br>CMD echo “finished,-----------success1”<br>CMD /bin/bash<br>说明：<br>出于可移植和分享的考虑，用-v主机目录：容器目录这种方法不能够直接在Dockerfile中实现。<br>由于宿主机目录是依赖于特定宿主机的，并不能够保证所有的宿主机都存在这样的特定目录。</p><p>docker build -f /mydocker/DockerFile -t zzyy/centos .</p><p>通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址在哪？<br>Docker挂载主机目录Docker访问出现cannot open directoru :Permission denied<br>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><h2 id="什么是数据卷容器？">什么是数据卷容器？</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</p><p>docker run -it --name ch02 --volumes-from ch01 zzyy/centos</p><p>问题: 然后docker ps -a进行查看，会发现容器已经退出<br>很重要的要说明一点:Docker容器后台运行，就必须有一个前台进程。<br>容器运行的命令如果部署那些一直挂机的命令(比如运行top,tail)，就是会自动退出的。</p><h1>DockerFile解析</h1><h2 id="DockerFile是什么？">DockerFile是什么？</h2><p>Dockerfiles是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。<br>构建的三步骤</p><ul><li>编写Dockerfile文件</li></ul><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta">  #</span><span class="bash"> volume <span class="hljs-built_in">test</span></span><br>  FROM centos<br>  VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]<br>  CMD echo &quot;finished,-----------success1&quot;<br>  CMD /bin/bash<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>docker build</li><li>docker run</li></ul><h3 id="Dockerfile内容基础知识">Dockerfile内容基础知识</h3><ol><li>每条指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像层进行提交</li></ol><h3 id="Docker执行Dockerfile的大致流程">Docker执行Dockerfile的大致流程</h3><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有的指令都执行完成</li></ol><h3 id="小总结-2">小总结</h3><p>从应用软件的角度来看，Dockerfule、Docker镜像与Docker容器分别代表软件的三个不同阶段，<br>Dockerfile是软件的原材料<br>Docker镜像是软件的交付品<br>Docker容器则可以认为是软件的运行态<br>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。<br><img src= "/img/loading.gif" data-lazy-src="/posts/f59415f7/dockerfile.png" alt="*"></p><h2 id="Dockerfile体系结构-保留字指令">Dockerfile体系结构(保留字指令)</h2><p>FROM:基础镜像，当前新镜像是基于哪个镜像的<br>MAINTAINER:镜像维护者的姓名和邮箱地址<br>Run:容器构建时需要运行的命令<br>EXPOSE:当前容器对外暴露出的端口<br>WORKDIR:指定在创建容器后，终端默认登录的进来工作目录，一个落脚点<br>ENV: 用来在构建镜像过程中设置环境变量<br>例如:<br>EVN MY_PATH /usr/mytest<br>这个环境变量可以在后续的任何RUN指令中使用，着就如同在命令前面指定环境变量前缀一样；也可以在其他指令中直接使用这些变量 比如：WORKDIR $MY_PATH<br>ADD:将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包<br>COPY:类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层镜像内&lt;目标路径&gt;位置<br>VOLUME: 容器数据卷，用于数据保存和持久化工作<br>CMD:指定一个容器启动时要运行的命令。Dockfile中可以包含多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换<br>ENTRYPOINT:指定一个容器启动时要运行的命令。ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数<br>ONBUILD:当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p><h1>本地镜像发布到阿里云</h1><blockquote><p>sudo docker login --username=[用户名] <a href="http://registry.cn-hangzhou.aliyuncs.com">registry.cn-hangzhou.aliyuncs.com</a><br>sudo docker tag [ImageId] <a href="http://registry.cn-hangzhou.aliyuncs.com/llzzbbbuy/mycentons:%5B%E9%95%9C%E5%83%8F%E7%89%88%E6%9C%AC%E5%8F%B7%5D">registry.cn-hangzhou.aliyuncs.com/llzzbbbuy/mycentons:[镜像版本号]</a><br>sudo docker push <a href="http://registry.cn-hangzhou.aliyuncs.com/llzzbbbuy/mycentons:%5B%E9%95%9C%E5%83%8F%E7%89%88%E6%9C%AC%E5%8F%B7%5D">registry.cn-hangzhou.aliyuncs.com/llzzbbbuy/mycentons:[镜像版本号]</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jenkins+git+maven集成部署</title>
    <link href="https://xiang.bio/posts/e49f0579.html"/>
    <id>https://xiang.bio/posts/e49f0579.html</id>
    <published>2020-10-16T01:04:43.000Z</published>
    <updated>2020-10-16T01:31:43.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>jenkins+git+maven集成部署</h1><h2 id="什么是jenkins">什么是jenkins?</h2><blockquote><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p></blockquote><h2 id="使用jenkins的好处">使用jenkins的好处</h2><ol><li>解放了重复性劳动<br>自动化部署工作可以解放了集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工的高很多。</li><li>更快地修复问题<br>由于持续集成更早的获取变更，更早的进入测试，也就能更早的发现问题，解决问题的成本显著下降。</li><li>更快地交付成果<br>及早集成、及早测试减少了缺陷遗留到部署环节的机会。在某些情况下，更早地查找错误还会减少解决错误所需的工作量。<br>如果集成服务器对代码进行构建过程中发现错误，可以及时发送邮件或者短信提供给开发人员进行修复。<br>如果集成服务器在部署环节发现当前版本有问题不可用，集成服务器会将部署回退到上一个版本。这样服务器上始终都会有一个可用的版本。</li><li>减少手工的错误<br>人与机器的一个最大的区别是，在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。所以，当我们搭建完成集成服务器后，以后的事就交给集成服务器、来打理吧。</li><li>减少了等待时间<br>持续集成缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时间。持续集成，意味着开发、集成、测试、部署也得以持续。</li><li>更高的产品质量<br>集成服务器往往提供 Code review、代码质量检测等功能。对代码不规范或者有错误的地方会进行标识，也可以设置邮件、短信等进行告警。而开发人员通过 Code review 也可以持续提高编程的能力。</li></ol><h2 id="jenkins的执行过程">jenkins的执行过程</h2><p><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/jj.png" alt="*"><br>分别用了3台服务器来进行演示jenkins是如何进行集成部署的<br><em>当开发人员提交代码到git或者svn仓库中时，jenkins就会去仓库中拉取最新的代码，进行编译、测试、打包、部署，最终打包在tomcat服务器中</em></p><h2 id="jenkins安装">jenkins安装</h2><p>先去官网下好jenkins的war包，该war包在linux和windows是通用的  <a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a><br>下好之后把jenkins.war包放在tomcat中的wabaps中然后启动tomcat就行了，<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/1.png" alt="*"><br>启动之后，需要先去提示找到密码进行登录，登录之后选择“安装推荐插件”，安装完之后就出现如下，<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/3.png" alt="*"><br>现在我们需要先去安装jenkins的插件来执行自动集成的操作，<br>选择左侧的Manage Jenkins →Manage Plugins→安装Deploy to container Plugin插件<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/4.png" alt="*"><br>然后在去全局工具配置中配置git、maven、jdk,并设置maven的settings.xml的位置，该配置用于jenkins用于打包pom文件中jar包<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/5.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/6.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/7.png" alt="*"><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/8.png" alt="*"><br>接下来配置完后就可以创建一个项目了<br>去首页新建item选择第一个选项 “自由的项目”<br>配置git的项目地址 Repository URL 输入 你要拉取项目的地址并在Credentials中设置git账号和密码<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/9.png" alt="*"><br>构建触发器，这个就是用来去git/svn仓库去拉取代码，我选择了第一个，用钩子程序来通知jenkins来工作，身份验证令牌的格式：<a href="http://xn--ip-im8ckc">http://ip地址</a>:端口号/jenkins/job/apple/build?token=ATGUIGU_TOKEN<br>ATGUIGU_TOKEN代表身份验证令牌的名称，定义之后可以在浏览器中输入  来执行jenkins<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/10.png" alt="*"><br>告诉maven以什么样的方式进行构建，每次执行都会执行clean package操作<br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/11.png" alt="*"><br>到这一步就是jenkins已经打包好了，准备部署到tomcat服务器上，WAR/EAR files设置war包的位置，Context path设置启动tomcat以什么样的方式访问  我这配置的访问路径  <a href="http://192.168.253.8:8080/apple">http://192.168.253.8:8080/apple</a><br><img src= "/img/loading.gif" data-lazy-src="/posts/e49f0579/12.png" alt="*"><br>到这就配置完了，就可以开始执行jenkins了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python爬虫总结</title>
    <link href="https://xiang.bio/posts/915f1f31.html"/>
    <id>https://xiang.bio/posts/915f1f31.html</id>
    <published>2020-09-28T01:08:38.000Z</published>
    <updated>2020-09-28T03:02:48.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>爬虫是什么?</h1><blockquote><p>网络爬虫，又被称为网页蜘蛛，网络机器人，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本<br>大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。<br>简单来讲，爬虫就是一个探测机器，它的基本操作就是模拟人的行为去各个网站溜达，点点按钮，查查数据，或者把看到的信息背回来。就像一只虫子在一幢楼里不知疲倦地爬来爬去。<br>可以简单地想象：每个爬虫都是你的“分身”。就像孙悟空拔了一撮汗毛，吹出一堆猴子一样。<br>我们每天使用的百度，其实就是利用了这种爬虫技术：每天放出无数爬虫到各个网站，把他们的信息抓回来，然后化好淡妆排着小队等你来检索。</p></blockquote><h1>爬虫的BeautifulSoup库详解</h1><p>BeautifulSoup灵活又方便的网页解析库，处理高效，支持多种解析器。<br>利用它不用编写正则表达式即可方便地实现网页信息的提取。</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><h2 id="基本使用">基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="hljs-string">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.prettify())      <span class="hljs-comment"># 输出文档中所有内容</span><br>print(soup.title.string)    <span class="hljs-comment"># 输出&lt;title&gt;标签内容</span><br></code></pre></td></tr></table></figure><h2 id="标签选择器">标签选择器</h2><h3 id="选择元素">选择元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.title)<span class="hljs-comment"># 输出title标签</span><br>print(type(soup.title))<span class="hljs-comment"># 输出标签类型</span><br>print(soup.head) <span class="hljs-comment"># 输出hean标签</span><br>print(soup.p)<span class="hljs-comment"># 输出第一个p标签</span><br></code></pre></td></tr></table></figure><h3 id="获取名称">获取名称</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.title.name)<span class="hljs-comment"># 输出标签名</span><br></code></pre></td></tr></table></figure><h3 id="获取属性">获取属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.p.attrs[<span class="hljs-string">&#x27;name&#x27;</span>])<span class="hljs-comment"># 输出p标签中name属性值</span><br>print(soup.p[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-comment"># 输出p标签中name属性值</span><br></code></pre></td></tr></table></figure><h3 id="获取内容">获取内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.p.string) <span class="hljs-comment"># 输出p标签中的内容</span><br></code></pre></td></tr></table></figure><h3 id="嵌套选择">嵌套选择</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.head.title.string) <span class="hljs-comment"># 输出title中的内容</span><br></code></pre></td></tr></table></figure><h2 id="标准选择器">标准选择器</h2><h3 id="find-all-name-attrs-recursive-text-kwargs">find_all( name , attrs , recursive , text , **kwargs )</h3><p>可根据标签名、属性、内容查找文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">html=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="hljs-string">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.find_all(<span class="hljs-string">&#x27;ul&#x27;</span>))<span class="hljs-comment"># find_all是一个list,输出全部&lt;ul&gt;</span><br>print(type(soup.find_all(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># 获得第一个ul的类型</span><br></code></pre></td></tr></table></figure><h3 id="find-name-attrs-recursive-text-kwargs">find( name , attrs , recursive , text , **kwargs )</h3><p>find返回单个元素，find_all返回所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>))<span class="hljs-comment"># 找到第一个ul</span><br>print(type(soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>))) <span class="hljs-comment">#找到第一个ul类型</span><br>print(soup.find(<span class="hljs-string">&#x27;page&#x27;</span>))<span class="hljs-comment">#查找page</span><br></code></pre></td></tr></table></figure><p><strong>find_parents() find_parent()</strong><br>find_parents()返回所有祖先节点，find_parent()返回直接父节点。</p><p><strong>find_next_siblings() find_next_sibling()</strong><br>find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。</p><p><strong>find_previous_siblings() find_previous_sibling()</strong><br>find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。</p><p><strong>find_all_next() find_next()</strong><br>find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点</p><p><strong>find_all_previous() 和 find_previous()</strong><br>find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点</p><h2 id="CSS选择器">CSS选择器</h2><p>通过select()直接传入CSS选择器即可完成选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">html=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="hljs-string">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="hljs-string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>print(soup.select(<span class="hljs-string">&#x27;.panel .panel-heading&#x27;</span>))<br>print(soup.select(<span class="hljs-string">&#x27;ul li&#x27;</span>))<br>print(soup.select(<span class="hljs-string">&#x27;#list-2 .element&#x27;</span>))<br>print(type(soup.select(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li>推荐使用lxml解析库，必要时使用html.parser</li><li>标签选择筛选功能弱但是速度快</li><li>建议使用find()、find_all() 查询匹配单个结果或者多个结果</li><li>如果对CSS选择器熟悉建议使用select()</li><li>记住常用的获取属性和文本值的方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis实现主从复制</title>
    <link href="https://xiang.bio/posts/39474014.html"/>
    <id>https://xiang.bio/posts/39474014.html</id>
    <published>2020-08-21T02:35:07.000Z</published>
    <updated>2020-08-21T03:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Redis主从复制？">什么是Redis主从复制？</h2><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，<br>但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/1.png" alt="*"><br>说明:</p><ul><li>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</li><li>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。只有一个主redis，可以有多个从redis。</li><li>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</li><li>一个redis可以即是主又是从</li></ul><h2 id="主从配置">主从配置</h2><p>现在我们需要修改redis中的redis.conf中的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">将daemonze由no改为yes(Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程)<br>#bind 127.0.0.1 取消绑定本机IP  任意主机都能连上<br>daemonize yes 守护进程修改yes<br>protected-mode no保护模式，修改成NO<br>replicaof 主redis IP地址 端口号修改主从同步配置(只需要改从服务器)<br></code></pre></td></tr></table></figure><p>现在就要 开始启动redis看看效果，redis启动主要分为<strong>前端启动</strong>和<strong>后端启动</strong></p><h3 id="前端启动-font-color-red-不推荐-font">前端启动(<font color="red">不推荐</font>)</h3><ul><li>启动命令：redis-server，直接运行bin/redis-server将以前端模式启动。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-server<br></code></pre></td></tr></table></figure></li><li>关闭命令：ctrl+c</li></ul><p>启动缺点：客户端窗口关闭则redis-server程序结束，不推荐使用此方法<br>启动图例<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/2.png" alt="*"></p><h3 id="后端启动-守护线程启动">后端启动(守护线程启动)</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">redis-server redis.conf<br></code></pre></td></tr></table></figure><h3 id="后端启动的关闭方式">后端启动的关闭方式</h3><ul><li>非正常关闭（不推荐使用）：</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">kill -9  pid <br></code></pre></td></tr></table></figure><ul><li>正常关闭</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-cli shutdown<br></code></pre></td></tr></table></figure><h3 id="其他命令说明">其他命令说明</h3><ul><li>redis-server ：启动redis服务</li><li>redis-cli ：进入redis命令客户端</li><li>redis-benchmark： 性能测试的工具</li><li>redis-check-aof ： aof文件进行检查的工具</li><li>redis-check-dump ：  rdb文件进行检查的工具</li><li>redis-sentinel ：  启动哨兵监控服务</li></ul><p>启动redis图解<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/3.png" alt="*"></p><p>分别启动主redis和从redis服务，会发现从redis只有读的权限没有写的权限，并且主redis插入数据时从redis会同步更新(会有1秒左右的延迟)，下图就实现了reids的主从复制<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/4.png" alt="*"></p><h3 id="实现原理">实现原理</h3><ul><li>Redis的主从同步，分为全量同步和增量同步。</li><li>只有从机第一次连接上主机是全量同步</li><li>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</li><li>除此之外的情况都是增量同步<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/5.png" alt="*"></li></ul><h2 id="Redis-Sentinel哨兵机制">Redis Sentinel哨兵机制</h2><p>*** Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举 ***</p><h3 id="什么是哨兵机制？">什么是哨兵机制？</h3><ul><li>Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态</li><li>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</li><li>通俗的话来说就是一个保安负责小区的安全，每天监控着小区，redis中的哨兵机制亦是如此，监控着主从redis中当我们的主redis挂掉以后，可以让从redis顶上主redis的位置，实现高可用</li></ul><h3 id="哨兵进程的作用">哨兵进程的作用</h3><ol><li>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</li><li>提醒(Notification)： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作。</li></ol><ul><li>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</li><li>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</li><li>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</li></ul><h3 id="哨兵进程的工作方式">哨兵进程的工作方式</h3><ol><li>每个Sentinel（哨兵）进程以<font color="red">每秒钟一次</font>的频率向整个集群中的<font color="red">Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程</font>发送一个<font color="red">PING</font>  命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为<font color="red">主观下线（SDOWN）</font>。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<font color="red">所有 Sentinel（哨兵）</font>进程要以每秒一次的频率<font color="red">确认Master主服务器</font>的确<font color="red">进入了主观下线状态</font>。</li><li><font color="red">当有足够数量的Sentinel（哨兵）</font>进程（大于等于配置文件指定的值）在指定的时间范围内<font color="red">确认Master主服务器进入了主观下线状态（SDOWN）</font>， 则Master主服务器会被标记为<font color="red">客观下线（ODOWN）</font>。</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为<font color="red">客观下线（ODOWN）</font>时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。<br><img src= "/img/loading.gif" data-lazy-src="/posts/39474014/6.png" alt="*"></li></ol><p>只需要修改从redis中sentinel.conf</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-cli shutdown<br></code></pre></td></tr></table></figure><ul><li>启动主redis和从redis后，通过redis-sentinel启动哨兵服务</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">.&#x2F;redis-sentinel sentinel.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
